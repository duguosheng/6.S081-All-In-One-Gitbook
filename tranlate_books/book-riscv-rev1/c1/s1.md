# 1.1 进程和内存
Xv6进程由用户空间内存(指令、数据和堆栈)和对内核私有的每个进程状态组成。Xv6分时进程: 它透明地在等待执行的进程集合中切换可用的CPU。当一个进程没有执行时，xv6保存它的CPU寄存器，并在下一次运行该进程时恢复它们。内核利用进程id或PID标识每个进程。

一个进程可以使用fork系统调用创建一个新的进程。Fork创建了一个新的进程，其内存内容与调用进程（称为父进程）完全相同，称其为子进程。Fork在父子进程中都返回值。在父进程中，fork返回子类的PID；在子进程中，fork返回零。例如，考虑下面用C语言编写的程序片段

```c
// fork()在父进程中返回子进程的PID
// 在子进程中返回0
int pid = fork();
if(pid > 0) {
    printf("parent: child=%d\n", pid);
    pid = wait((int *) 0);
    printf("child %d is done\n", pid);
} else if(pid == 0) {
    printf("child: exiting\n");
    exit(0);
} else {
    printf("fork error\n");
}
```

`exit`系统调用导致调用进程停止执行并释放资源（如内存和打开的文件）。`exit`接受一个整数状态参数，通常0表示成功，1表示失败。`wait`系统调用返回当前进程的已退出(或已杀死)子进程的PID，并将子进程的退出状态复制到传递给`wait`的地址；如果调用方的子进程都没有退出，那么wait等待一个子进程退出。如果调用者没有子级，`wait`立即返回-1。如果父进程不关心子进程的退出状态，它可以传递一个0地址给`wait`。

在这个例子中，输出

```
parent: child=1234
child: exiting
```

可能以任何一种顺序出来，这取决于父或子谁先到达`printf`调用。子进程退出后，父进程的`wait`返回，导致父进程打印

```
parent: child 1234 is done
```

尽管最初子进程与父进程有着相同的内存内容，但是二者在运行中拥有不同的内存空间和寄存器：在一个进程中改变变量不会影响到另一个进程。例如当`wait`的返回值存入父进程的变量`pid`中时，并不会影响子进程中的`pid`，子进程中`pid`仍然为0。

`exec`系统调用使用从文件系统中存储的文件所加载的新内存映像替换调用进程的内存。（百度百科：根据指定的文件名找到可执行文件，并用它来取代调用进程的内容，换句话说，就是在调用进程内部执行一个可执行文件）该文件必须有特殊的格式，它指定文件的哪部分存放指令，哪部分是数据，以及哪一条指令用于启动等等。xv6使用ELF格式（将会在第三章详细讨论）。当`exec`执行成功，它不向调用进程返回数据，而是使加载自文件的指令在`ELF header`中声明的程序入口处开始执行。`exec`有两个参数：可执行文件的文件名和字符串参数数组。例如

```c
char* argv[3];
argv[0] = "echo";
argv[1] = "hello";
argv[2] = 0;
exec("/bin/echo", argv);
printf("exec error\n");
```

这个代码片段将调用程序替换为了参数列表为`echo hello`的`/bin/echo`程序运行，多数程序忽略参数数组中的第一个元素，它通常是程序名。

xv6的shell使用上述调用为用户运行程序。shell的主要结构很简单，请参见`main`(***user/sh.c:145***)。主循环使用`getcmd`函数从用户的输入中读取一行，然后调用`fork`创建一个shell进程的副本。父进程调用`wait`，子进程执行命令。例如：当用户向shell输入`echo hello`时，`runcmd`(***user/sh.c:58***) 将以`echo hello`为参数被调用来执行实际命令。对于“`echo hello`”，它将调用`exec`(***user/sh.c:78***)。如果`exec`成功，那么子进程将从`echo`而不是`runcmd`执行命令，在某刻`echo`会调用`exit`，这将导致父进程从`main`(***user/sh.c:78***)中的`wait`返回。

你或许想知道为什么`exec`和`fork`没有组合成为一个系统调用，稍后我们将会看到shell在其I/O重定向的实现中利用了这种分离。为了避免创建一个重复的进程然后立即替换它(使用`exec`)的浪费，操作内核通过使用虚拟内存技术(如copy-on-write)优化 fork 在这个用例中的实现(见第 4.6 节)。

Xv6 隐式地分配大多数用户空间内存:`fork`分配父内存的子副本所需的内存，`exec`分配足够的内存来保存可执行文件。在运行时需要更多内存的进程(可能是`malloc`)可以调用 `sbrk(n)`将其数据内存增加n个字节; `sbrk`返回新内存的位置。